# -*- coding: utf-8 -*-
"""crypto_prediction_colab.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D10S6xcdRx55Z1Ph13E4di-zhvGdwO0P
"""

# Install required packages
!pip install requests pandas numpy scikit-learn matplotlib seaborn plotly websocket-client ta

# -----------------------------------------------
# crypto_prediction_colab.py
# -----------------------------------------------

import requests
import pandas as pd
import numpy as np
import threading
import time
import json
from datetime import datetime, timedelta

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import TimeSeriesSplit

import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objs as go
from plotly.subplots import make_subplots

import websocket

# Suppress warnings
import warnings
warnings.filterwarnings("ignore")


# -----------------------------------------------
# 1. CoinGecko API wrapper
# -----------------------------------------------
class CoinGeckoAPI:
    BASE_URL = "https://api.coingecko.com/api/v3"

    @staticmethod
    def fetch_historical_prices(symbol: str, vs_currency: str = "usd", days: int = 90) -> pd.DataFrame:
        """
        Fetch historical daily price, volume, and market_cap for 'symbol' over the past 'days'.
        Returns a DataFrame indexed by date.
        """
        endpoint = f"{CoinGeckoAPI.BASE_URL}/coins/{symbol}/market_chart"
        params = {"vs_currency": vs_currency, "days": days, "interval": "daily"}
        resp = requests.get(endpoint, params=params)
        data = resp.json()
        df = pd.DataFrame({
            "date": [pd.to_datetime(pt[0], unit="ms") for pt in data["prices"]],
            "price": [pt[1] for pt in data["prices"]],
            "volume": [vt[1] for vt in data["total_volumes"]],
            "market_cap": [mc[1] for mc in data["market_caps"]],
        })
        df.set_index("date", inplace=True)
        return df


# -----------------------------------------------
# 2. Feature Engineering Utilities
# -----------------------------------------------
class CryptoDataProcessor:
    @staticmethod
    def add_technical_indicators(df: pd.DataFrame) -> pd.DataFrame:
        """
        Compute rolling statistical and technical indicators:
         - Simple moving averages (window 7, 21)
         - Exponential moving average (window 14)
         - Rolling volatility (window 14)
         - Relative Strength Index (RSI, window 14)
        """
        df = df.copy()
        df["sma_7"] = df["price"].rolling(window=7).mean()
        df["sma_21"] = df["price"].rolling(window=21).mean()
        df["ema_14"] = df["price"].ewm(span=14, adjust=False).mean()
        df["volatility_14"] = df["price"].rolling(window=14).std()

        # RSI
        delta = df["price"].diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.rolling(window=14).mean()
        avg_loss = loss.rolling(window=14).mean()
        rs = avg_gain / avg_loss
        df["rsi_14"] = 100 - (100 / (1 + rs))

        # Lag features
        df["lag_1"] = df["price"].shift(1)
        df["lag_7"] = df["price"].shift(7)

        df.dropna(inplace=True)
        return df


# -----------------------------------------------
# 3. Prediction Model
# -----------------------------------------------
class CryptoPredictionModel:
    def __init__(self, model_type: str = "random_forest"):
        """
        model_type: 'linear' or 'random_forest'
        """
        if model_type == "linear":
            self.model = LinearRegression()
        else:
            self.model = RandomForestRegressor(n_estimators=100, random_state=42)

    def train(self, X: pd.DataFrame, y: pd.Series):
        self.model.fit(X, y)

    def predict(self, X: pd.DataFrame) -> np.ndarray:
        return self.model.predict(X)

    def evaluate(self, X: pd.DataFrame, y: pd.Series) -> dict:
        preds = self.predict(X)
        return {
            "mse": mean_squared_error(y, preds),
            "mae": mean_absolute_error(y, preds),
            "r2": r2_score(y, preds)
        }


# -----------------------------------------------
# 4. Real‚Äêtime Data Streaming via Binance WebSocket
# -----------------------------------------------
class BinanceWebSocket:
    """
    Streams live trade data (price) for a given symbol from Binance.
    """

    def __init__(self, symbol: str, on_message):
        """
        symbol: lowercase symbol, e.g. 'btcusdt'
        on_message: callback function taking (timestamp, price)
        """
        self.ws = None
        self.symbol = symbol.lower()
        self.on_message = on_message
        self.url = f"wss://stream.binance.com:9443/ws/{self.symbol}@trade"
        self.thread = None
        self.keep_running = False

    def _connect(self):
        self.ws = websocket.WebSocketApp(
            self.url,
            on_message=self._handle_message,
            on_error=lambda ws, e: print("WebSocket error:", e),
            on_close=lambda ws: print("WebSocket closed")
        )
        self.ws.run_forever()

    def _handle_message(self, ws, message):
        data = json.loads(message)
        ts = datetime.fromtimestamp(data["T"] / 1000.0)
        price = float(data["p"])
        self.on_message(ts, price)

    def start(self):
        self.keep_running = True
        self.thread = threading.Thread(target=self._connect)
        self.thread.daemon = True
        self.thread.start()
        time.sleep(1)  # allow connection setup

    def stop(self):
        self.keep_running = False
        if self.ws:
            self.ws.close()
        if self.thread:
            self.thread.join()


# -----------------------------------------------
# 5. End‚Äêto‚ÄêEnd Runner
# -----------------------------------------------
def run_crypto_prediction(
    symbol: str,
    days: int = 90,
    model_type: str = "random_forest",
    enable_realtime: bool = True
):
    """
    Fetch historical data, engineer features, train model,
    evaluate backtest, and optionally start real-time prediction.
    Returns evaluation metrics and live updates.
    """
    print(f"‚ñ∂Ô∏è Fetching last {days} days of {symbol} data from CoinGecko...")
    hist_df = CoinGeckoAPI.fetch_historical_prices(symbol, days=days)
    proc_df = CryptoDataProcessor.add_technical_indicators(hist_df)

    # Prepare training data
    X = proc_df.drop(columns=["price"])
    y = proc_df["price"]

    # TimeSeries cross‚Äêvalidation
    tscv = TimeSeriesSplit(n_splits=5)
    metrics = []
    for train_idx, test_idx in tscv.split(X):
        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]
        model = CryptoPredictionModel(model_type=model_type)
        model.train(X_train, y_train)
        evals = model.evaluate(X_test, y_test)
        metrics.append(evals)

    # Average metrics
    avg_metrics = {k: np.mean([m[k] for m in metrics]) for k in metrics[0]}
    print("üîç Cross‚Äêvalidated performance:", avg_metrics)

    # Final training on all data
    final_model = CryptoPredictionModel(model_type=model_type)
    final_model.train(X, y)

    # Plot historical vs. prediction for last 30 days
    last_30 = proc_df.iloc[-30:]
    preds_30 = final_model.predict(last_30.drop(columns=["price"]))
    plt.figure(figsize=(12, 4))
    plt.plot(last_30.index, last_30["price"], label="Actual")
    plt.plot(last_30.index, preds_30, label="Predicted")
    plt.title(f"{symbol.upper()} Price: Actual vs Predicted (Last 30 days)")
    plt.legend()
    plt.show()

    # Real‚Äêtime streaming and prediction
    if enable_realtime:
        live_prices = []
        live_times = []

        def on_ws_message(ts, price):
            live_times.append(ts)
            live_prices.append(price)
            df_live = pd.DataFrame({
                "price": live_prices
            }, index=live_times)
            df_live = CryptoDataProcessor.add_technical_indicators(
                pd.concat([hist_df, df_live]).dropna()
            )
            X_live = df_live.drop(columns=["price"])
            pred = final_model.predict(X_live.iloc[[-1]])[0]

            # Clear and redraw
            plt.clf()
            plt.plot(df_live.index[-100:], df_live["price"].iloc[-100:], color="blue")
            plt.scatter(df_live.index[-1], pred, color="red")
            plt.title(f"Live {symbol.upper()} Price & Prediction: {pred:.2f} USD")
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.pause(0.01)

        ws = BinanceWebSocket(symbol + "usdt", on_message=on_ws_message)
        plt.ion()
        ws.start()
        print("‚ö° Streaming live data and predictions. Close the plot window to stop.")
        try:
            while True:
                time.sleep(0.1)
        except KeyboardInterrupt:
            ws.stop()
            print("\nüõë Streaming stopped by user.")

    return {"cv_metrics": avg_metrics, "model": final_model}


# -----------------------------------------------
# 6. Example Usage in Colab
# -----------------------------------------------
if __name__ == "__main__":
    # Example: run for Bitcoin, 90‚Äêday history, random forest, with live stream
    results = run_crypto_prediction("bitcoin", days=90, model_type="random_forest", enable_realtime=True)
    print("‚úÖ Done. CV metrics:", results["cv_metrics"])